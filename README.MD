## Ответы на устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?
- Строки в Go - это неизменяемый тип данных, использующий срез байтов для хранения информации. При конкатенации возникает необходимость выделения памяти, что отрицательно сказывается на производительности.
- Когда нужно объединить существенное количество строк лучшим решением будет воспользоваться типом ```Builder``` из пакета ```strings```:

```go
var b strings.Builder
n := 999
b.Grow(n)
for i := 0; i < n; i++ {
    b.WriteString("(ノಠ益ಠ)ノ彡┻━┻")
}
fmt.Println(b.String())
```
---
### 2. Что такое интерфейсы, как они применяются в Go?
- Интерфейсы имеют фундаментальное значение в Go. Прежде всего, при помощи интерфейсов описывается некоторое поведение объекта путем перечисления сигнатур методов. Это позволяет создавать абстракции и не зависеть от конкретных реализаций.
- Тип соответствует какому-либо интерфейсу, если он полностью реализует все методы данного интерфейса. Соответствие интерфейсу не обозначается ключевыми словами, а подразумевается за счет механизма неявной типизации. Подобный подход позволяет полиморфно работать с различными не связанными между собой структурами, пока они поддерживают необходимый набор методов.
- Любой тип в Go соответствует пустому интерфейсу ```interface{}```. Пустой интерфейс не содержит никаких методов и абстракций. Он может быть полезен, когда нужно работать с любым типом, который не известен заранее. 
- Переменная интерфейсного типа хранит в себе пару <конкретное значение, дескриптор типа значения>. Конкретное значение - это та область памяти, где хранится присвоенное значение. Дескриптор типа - описание того, какие методы могут быть вызваны для данного значения.
- Рекомендуется создавать тонкие интерфейсы, состоящие из одного, максимум двух методов. При необходимости их можно встроить в более общие интерфейсы.
- Переменная интерфейсного типа будет равна nil только в том случае, когда  и конкретное значение и дескриптор типа будут равны nil. Это может стать причиной возникновения ошибок. 

```go
type Interface interface {
	Method()
}

type Prog struct {
	S string
}

func (p Prog) Method() {
}

func NilTest(iface Interface) {
	fmt.Printf("Is nil value: %t\n", iface == nil)
	fmt.Printf("Value: %v | Concrete Type: %T\n", iface, iface)
}

func main(){
    var iface Interface

	// Is nil value: true
	fmt.Printf("Is nil value: %t\n", iface == nil)

	iface = Prog{"it is a value"}
	// Value: {it is a value} | Concrete Type: main.Prog
	fmt.Printf("Value: %v | Concrete Type: %T\n", iface, iface)

	iface = &Prog{"it is a pointer"}
	// Value: &{it is a pointer} | Concrete Type: *main.Prog
	fmt.Printf("Value: %v | Concrete Type: %T\n", iface, iface)

	var p *Prog = nil

	// Is nil value: false
	// Value: <nil> | Concrete Type: *main.Prog
	NilTest(p)
}
```

---
### 3. Чем отличаются RWMutex от Mutex?
- Mutex полностью блокирует/разблокирует одновременный доступ к некоторому участку кода при вызове методов Lock и Unlock.
- RWMutex имеет дополнительные методы RLock и RUnlock, которые позволяют сообщить, что производится чтение некоторого ресурса. В отличии от Mutex, несколько горутин могут получить RLock mutex. Важно отметить, что попытка начать запись в данный ресурс с предварительным использованием метода Lock будет заблокирована до тех пор, пока все операции чтения не завершатся и не освободят mutex. 

---
### 4. Чем отличаются буферизированные и не буферизированные каналы?
- Небуферизированный канал позволяет отправлять по одному сообщению за раз. Горутина-отправитель блокируется до тех пор, пока сообщение не будет получено другой горутиной.
- Буферизированный канал позволяет отправлять без блокировки столько сообщений, сколько указано в значении буфера. При заполнении буфера горутина-отправитель блокируется, пока не будет прочитано хотя бы одно сообщение.
---
### 5. Какой размер у структуры struct{}{}?  
- Размер структуры определяется суммой размеров типов данных для полей, из которых она состоит.  
- Размер пустой структуры - 0 байт.

---
### 6. Есть ли в Go перегрузка методов или операторов?
- В Go нет перегрузки методов или операторов.
---
### 7. В какой последовательности будут выведены элементы map[int]int?
```go
    m[0]=1
    m[1]=124
    m[2]=281
```

- При итерации элементы map выводятся в случайной последовательности независимо от очередности их добавления.

---

### 8. В чем разница make и new?
- new создает указатель на переданный тип.  
```var a = new(int)``` вернет указатель на значение типа int. При попытке разыменовывания (```*a```) будет получено значение по умолчанию для переданного типа (в данном случае: 0)
- make создает и инициализирует переменную составного типа: map, slice или chan. При попытке создать переменные указанных типов через new они примут значение nil, потому что для них не определено дефолтное значение,  и не будет возможности с ними работать. Это происходит потому, что им для инициализации требуется  выделить память под фундаментальные типы, на которых они основаны. В реализации метода new этого не предусмотрено.
---
### 9. Сколько существует способов задать переменную типа slice или map?
```go
//slice: 9 способов

1) var s1[]int                   // declare var
2) s2 := []int{}                 // empty slice
3) s3 := []int{1, 2, 3, 4, 5, 6} // slice with items
4) s4 := make([]int, 0)          // make with size arg
5) s5 := new([]int)              // with new (nil slice)
6) s6 := []rune("123")           // convert string to rune slice
7) s7 := s3[2:4]                 // slice from other slice
8) s8 := append(s7, 10, 11)      // append elements to slice

   arr := [5]int{1, 2, 3, 4, 5}
9) s9 := arr[:]                  // slice from array

//map: 6 способов

1) var m1 map[int]int           // declare var; nil map; cant be edited
2) m2 := make(map[string]int)   // make empty map
3) m3 := make(map[int]int, 5)   // make empty map of initial size
4) m4 := map[int]int{}          // empty map
5) m5 := map[string]int{"d": 1} // map with items
6) m6 := new(map[int]int)       // nil map; cant be edited
```


---
### 10. Что выведет данная программа и почему?
```go
func update(p *int) {
    b := 2
    p = &b
}
func main() {
    var (
        a=1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```
```
Вывод программы:

1
1
```
- В приведенном выше примере осуществляется попытка обновить значение переменной  в функции, принимающей указатель. Инструкция ```p = &b ``` переинициализирует исходный указатель, создавая локальную копию. При этом изменения никак не отражаются на указателе в функции main. 
- Чтобы обновить значение указателя ```p``` в функции ```update``` необхдимо внести следующее изменение: ```*p = b```. Теперь в адрес, который хранится в указатале ```p``` записывается новое число. Указатель из внешней функции по прежнему указывает на тот же самый адрес, а значит и на обновленное значение.

---
### 11. Что выведет данная программа и почему?
```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```
- Сначала программа будет выводить числа от 0 до 4 в некотором порядке. После этого будет получена ошибка:

```
fatal error: all goroutines are asleep - deadlock!
...
```
- Проблема возникает потому, что в горутины передается не указатель на структуру sync.WaitGroup, а копия этой структуры. При завершении выполнения горутина не удаляет себя из списка ожидания, так как она вызывает метод у копии структуры. При этом внешняя структура все еще ожидает выполнения 5 горутин и никогда не получит сигнал об их завершении. 
- Для исправления ситуации можно передать в горутины указатель на структуру WaitGroup или не передавать его, использовав замыкание.

---
### 12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
```
Вывод программы:

0
```
- Конструкция if создает новую область видимости, где переменная ```n``` переинициализируется. Любые изменения внутри данного блока после переинициализации никак не отражаются на внешней переменной.

---
### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
```
Вывод программы:

[100 2 3 4 5]
```
- Срезы в Go хранят указатель на массив значений. После передачи среза в функцию в качестве аргумента все изменения, производимые с массивом при доступе к элементам по индексу, отражаются на исходном срезе во внешней области.
- При изменении размера массива выделяется новый участок памяти, куда копируется его содержимое. Инструкция ```v = append(v, b)``` инициализировала новый срез в области видимости функции ```someAction```, но исходный срез все еще указывает на область памяти со старым массивом.

---
### 14. Что выведет данная программа и почему?
```go
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```
```
Вывод программы:

[b b a][a a]
```
- В анонимной функции происходит создание нового среза путем копирования значений из переданного среза и добавления нового. Новый срез никак не связан с исходным, поэтому изменения, сделанные в нем, не отражаются на срезе из внешней области видимости.
---
